service: workshop-${self:custom.name}

custom:
  name: ProductionReadyServerless
  email: christophergradwohl@gmail.com

provider:
  name: aws
  runtime: nodejs12.x

  # By default, one IAM Role is shared by all of the Lambda functions in your service.
  # To add specific rights to this service-wide Role, define statements in provider.iamRoleStatements which will be merged into the generated policy.
  # Our Lambda functions assume this IAM role during execution !
  iamRoleStatements:
    # ***
    # * This adds the dynamodb:scan permission to the Lambda execution role.
    # ***
    - Effect: Allow
      Action: dynamodb:scan
      Resource: !GetAtt RestaurantsTable.Arn
      #  ***
      #  * Adds'execute-api:Invoke' to the IAM execution role, using serverless-pseudo-parameters
      # ***
    - Effect: Allow
      Action: execute-api:Invoke
      # the request arn to /restaurants much match this template in order to get access.
      # here we are giving access to our other lambdas, via the default role to be able to invoke this resource
      # basically all this says is that our other AWS resources can invoke this api endpoint
      Resource: arn:aws:execute-api:#{AWS::Region}:#{AWS::AccountId}:#{ApiGatewayRestApi}/${self:provider.stage}/GET/restaurants

functions:
  get-index:
    handler: functions/get-index.handler
    events:
      - http:
          path: /
          method: get
    environment:
      restaurants_api:
        Fn::Join:
        - ''
        - - "https://"
          - !Ref ApiGatewayRestApi
          - ".execute-api.${self:provider.region}.amazonaws.com/${self:provider.stage}/restaurants"
      # this is the user pool itself, A user pool is a user directory in Amazon Cognito. With a user pool, your users can sign in to your web or mobile app through Amazon Cognito.
      cognito_user_pool_id: !Ref CognitoUserPool
      # you need an app client ID and an optional client secret. It is your responsibility to secure any app client IDs or secrets so that only authorized client apps can call these
      # unauthenticated APIs. You can create multiple apps for a user pool, and generally an app corresponds to the platform of an app.
      cognito_client_id: !Ref WebCognitoUserPoolClient
  
  get-restaurants:
    handler: functions/get-restaurants.handler
    events:
      - http:
          path: /restaurants
          method: get
          # now this function requires an IAM Role, which for this exmple will live in the INVOKE EXECUTION IAM ROLE that we defined in the iamRoleStatements under the execute-api:Invoke Action
          # If you want to require that the caller submit the IAM user's access keys in order to be authenticated to invoke your Lambda Function, set the authorizer to aws_iam
          authorizer: aws_iam
    environment:
      restaurants_table: !Ref RestaurantsTable
  
  search-restaurants:
    handler: functions/search-restaurants.handler
    events:
      - http:
          path: /restaurants/search
          method: post
          # Here we are saying that /restaurants/search needs to be authed by a Cognito Authroizer, which is a managed service.
          authorizer:
            type: COGNITO_USER_POOLS
            authorizerId:
              Ref: CognitoAuthorizer
    environment:
      restaurants_table: !Ref RestaurantsTable
      
# CloudFormation
resources:
  # CloudFormation Resources
  Resources:
    RestaurantsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: name
            AttributeType: S
        KeySchema:
          - AttributeName: name
            KeyType: HASH
    # As an alternative to using IAM roles and policies or Lambda authorizers (formerly known as custom authorizers), 
    # you can use an Amazon Cognito user pool to control who can access your API in Amazon API Gateway.To use an Amazon
    # Cognito user pool with your API, you must first create an authorizer of the COGNITO_USER_POOLS type and then configure
    # an API method to use that authorizer. After the API is deployed, the client must first sign the user in to the user
    # pool, obtain an identity or access token for the user, and then call the API method with one of the tokens, which
    # are typically set to the request's Authorization header. The API call succeeds only if the required token is supplied
    # and the supplied token is valid, otherwise, the client isn't authorized to make the call because the client did not
    # have credentials that could be authorized.
    CognitoAuthorizer:
      Type: AWS::ApiGateway::Authorizer
      Properties:
        AuthorizerResultTtlInSeconds: 300
        IdentitySource: method.request.header.Authorization
        Name: Cognito
        RestApiId: !Ref ApiGatewayRestApi
        Type: COGNITO_USER_POOLS
        ProviderARNs:
          - !GetAtt CognitoUserPool.Arn
    CognitoUserPool:
      Type: AWS::Cognito::UserPool
      Properties:
        AliasAttributes:
          - email
        UsernameConfiguration:
          CaseSensitive: false
        AutoVerifiedAttributes:
          - email
        Policies:
          PasswordPolicy:
            MinimumLength: 8
            RequireLowercase: true
            RequireNumbers: true
            RequireUppercase: true
            RequireSymbols: true
        Schema:
          - AttributeDataType: String
            Mutable: true
            Name: given_name
            Required: true
            StringAttributeConstraints:
              MinLength: "1"
          - AttributeDataType: String
            Mutable: true
            Name: family_name
            Required: true
            StringAttributeConstraints:
              MinLength: "1"
          - AttributeDataType: String
            Mutable: true
            Name: email
            Required: true
            StringAttributeConstraints:
              MinLength: "1"
    WebCognitoUserPoolClient:
      Type: AWS::Cognito::UserPoolClient
      Properties:
        ClientName: web
        UserPoolId: !Ref CognitoUserPool
        ExplicitAuthFlows:
          - ALLOW_USER_SRP_AUTH
          - ALLOW_REFRESH_TOKEN_AUTH
        PreventUserExistenceErrors: ENABLED
    ServerCognitoUserPoolClient:
      Type: AWS::Cognito::UserPoolClient
      Properties:
        ClientName: server
        UserPoolId: !Ref CognitoUserPool
        ExplicitAuthFlows:
          - ALLOW_ADMIN_USER_PASSWORD_AUTH
          - ALLOW_REFRESH_TOKEN_AUTH
        PreventUserExistenceErrors: ENABLED
  # CloudFormation Outputs - This adds the resoursces to the cloudformation stack output!
  # The optional Outputs section declares output values that you can import into
  # other stacks (to create cross-stack references), return in response (to describe stack calls),
  # or view on the AWS CloudFormation console. For example, you can output the S3 bucket
  # name in a stack to make the bucket easier to find.
  Outputs:
    RestaurantsTableName:
      Value: !Ref RestaurantsTable

    CognitoUserPoolId:
      Value: !Ref CognitoUserPool

    CognitoUserPoolArn:
      Value: !GetAtt CognitoUserPool.Arn

    CognitoUserPoolWebClientId:
      Value: !Ref WebCognitoUserPoolClient

    CognitoUserPoolServerClientId:
      Value: !Ref ServerCognitoUserPoolClient

# Serverless Framework Plugins
plugins:
  - serverless-export-env
  - serverless-pseudo-parameters